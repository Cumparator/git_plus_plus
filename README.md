# Git++
Обертка над Git с новой архитектурой и философией. Мы хотим изменить некоторые ключевые концепции чтобы упростить использование и одновременно добавить новые возможности.
Ключевые идеи:
- Любое состояние рабочей директории можно закоммитить нодой в графе а обсолютно любое его место, без оглядки на логику изменений, без всяких ребейзов и тп.
- Можно пушить разные части графа в разные удаленные репозитории.

Зачем нужен селективный push?
- Чтобы вести экспериментальную разработку параллельно с основной, не загрязняя историю.
- Контекстное распространение функциональности разным аудиториям. Enterprise-клиенты получают одни функции, массовые пользователи — другие
- Обход корпоративных ограничений. Можно локально (или в личном репозитории) вести историю в удобном для себя стиле, не соблюдая командные правила пользования общим репозиторием, не рискуя запушить не те ветки.

# Архитектура обертки над Git

## Общая концепция
Система представляет собой обертку над Git, предназначенную для упрощения работы и добавления новых возможностей, а в будущем возможно и подмены гит на более удобную реализацию VCS.

## Слои архитектуры

### 1. UI-слой
- Пользовательский интерфейс
- Принимает команды от пользователя
- Передает запросы в слой бизнес-логики
- Предполагается в 2х форм-факторах, cli и gui.
- gui сопровождается визуализацией графа с интерактивным взаимодействием (выбор нод от которых будем коммитить например), тут же можно будет потом добавить отображение семантических связей в графе, при помощи цветных/пунктирных ребер, что-то подобное
- cli наверно хотелось бы видеть в несколько интерактивном режиме, чтоб меньше ручками писать, но и команды надо оставить
  ```shell
  add node_name // add или commit назвать хз
  amend node_name // возможно
  merge node1 node2
  fetch remote
  chrm +github.com/123/123 node3 // chrm типа change remote
  chrm 0 node4 // 0/none/null/notpushable хз
  ```

### 2. Слой бизнес-логики
- Ядро системы
- Абстрагируется от Git-концепций (ветки, коммиты)
- Работает с абстрактным графом версий
- Содержит основную логику работы с версиями

### 3. Слой реализации
- Низкоуровневое взаимодействие с Git
- Преобразует абстрактные операции в Git-команды
- Работает с физическим хранилищем
- разные репы (по одной на remote я полагаю?) лежат переименованные в .git_rep-name, .gitignore_rep-name и тп, для взаимодействия с конкретной репой создаётся симлинк .git -> .git_rep-name1

## Ключевые концепции

### Граф версий
- Не обязательно связный граф но обязательно состоит из DAG (Directed Acyclic Graph)
- Состоит из нод (узлов)
- Каждая нода представляет состояние рабочей директории (логика только изменений должна оставаться за кадром и с ней всякие ребейзы)

### Модель работы
- Любое текущее состояние рабочей директории можно добавить как новую ноду в любое место графа
- Нет сложностей с переключением между ветками/коммитами
- Нет необходимости в ребейзах

## Теги ~~и ветки~~
- Теги точно нужны, но от веток как от излишней абстракции я хочу избавиться, оставим вместо них просто теги которые будем двигать, или вообще копировать в дочерние ноды

## Функция селективного пуша

### Механизм remote-меток
- Каждая нода содержит массив `remote`
- При создании новой ноды массив `remote` копируется из родительской ноды по умолчанию
- Массив определяет, в какие удаленные репозитории можно пушить ноду

### Правила для совместимости с Git
- При операции push все ноды, которые пушатся, должны иметь непрерывную цепочку данных remotes до корневой ноды графа
- Ветки всё равно на самом деле будут ветками пока не подменим реализацию

### Возможности и преимущества
- Коммит и пуш в разные удаленные репозитории по отдельности либо одновременно
- Возможность помечать подграфы как непушабельные (не включать в push) (просто сделав пустой массив `remote`)
- Упрощенная логика, избавление от лишних сущностей




## Можно добавить
+ Семантические связи в графе (типа fix, analogue, alternative, refactor) разными там цветами и обозначениями. поиск и фильтрация по ним
+ ОЧЕНЬ хотелось бы сделать возможность добавлять плагины в той или иной форме